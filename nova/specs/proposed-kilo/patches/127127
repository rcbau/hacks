From 0f42e0acd76108c1d5e58cbff52698a15aa9e461 Mon Sep 17 00:00:00 2001
From: Christopher Yeoh <cyeoh@au1.ibm.com>
Date: Thu, 9 Oct 2014 14:05:10 +1030
Subject: [PATCH] WIP: REST API Microversions

Proposal to support microversions for the Nova REST API

Change-Id: I49c3d590d087f9cd3c2d1898455aa296721a4f6e
---
 specs/kilo/approved/api-microversions.rst | 358 ++++++++++++++++++++++++++++++
 1 file changed, 358 insertions(+)
 create mode 100644 specs/kilo/approved/api-microversions.rst

diff --git a/specs/kilo/approved/api-microversions.rst b/specs/kilo/approved/api-microversions.rst
new file mode 100644
index 0000000..0417bdf
--- /dev/null
+++ b/specs/kilo/approved/api-microversions.rst
@@ -0,0 +1,358 @@
+..
+ This work is licensed under a Creative Commons Attribution 3.0 Unported
+ License.
+
+ http://creativecommons.org/licenses/by/3.0/legalcode
+
+==========================================
+REST API Microversion Support
+==========================================
+
+https://blueprints.launchpad.net/nova/+spec/api-microversions
+
+We need a way to be able to introduce changes to the REST API to both
+fix bugs and add new features. Some of these changes are backwards
+incompatible and we currently have no way of doing this.
+
+Problem description
+===================
+
+As a community we are really good at evolving interfaces and code over
+time via incremental development. We've been less good at giant big
+bang drops of code. The Nova API has become sufficiently large, and
+constantly growing through new extensions, that it's not likely to be
+able to ever do a new major version of the API because of the impact
+on users and overhead for developers of supporting multiple
+implementations .
+
+At the same time the current situation where we allow innovation in
+the API through adding extensions, has grown to the point where we now
+have extensions to extensions, under the assumption that the extension
+list is a poor man's versioning mechanism. This has led to large
+amounts of technical debt. It prevents us from making certain changes,
+like deprecating pieces of the API that are currently non sensible or
+broken. Or fixing other areas where incremental development has led to
+inconsistencies in the API which is confusing for new users.
+
+We must come up with a better way that serves the following needs:
+
+- Makes it possible to evolve the API in an incremental manner, which
+  is our strength as a community.
+- Provides backwards compatibility for users of the REST API.
+- Provides cleanliness in the code to make it less likely that we'll
+  do the wrong thing when extending or modifying the API.
+
+A great interface is one that goes out of it's way to makes it hard to
+use incorrectly. A good interface tries to be a great interface, but
+bends to the realities of the moment.
+
+Use Cases
+----------
+
+* Allows developers to modify the Nova API in backwards compatible
+  way and signal to users of the API dynamically that the change is
+  available without having to create a new API extension.
+
+* Allows developers to modify the Nova API in a non backwards
+  compatible way whilst still supporting the old behaviour. Users of
+  the REST API are able to decide if they want the Nova API to behave
+  in the new or old manner on a per request basis.
+
+* Users of the REST API are able to, on a per request basis, decide
+  which version of the API they want to use (assuming the deployer
+  supports the version they want).
+
+* Deployers of Nova are able to support new features which cause
+  backwards incompatible changes to the Nova API without forcing all
+  users to modify the way they interact with the API, only those who
+  want the new feature.
+
+Project Priority
+-----------------
+
+The kilo priorities list is currently not defined. However under the
+currently proposed list of priorities it would fall under "User
+Experience" as it significantly increases the ability for us to
+improve the Nova API.
+
+Proposed change
+===============
+
+Design Priorities:
+
+* How will the end users use this, and how to we make it hard to use
+  incorrectly
+
+* How will the code be internally structured. How do we make it:
+
+** Easy to see in the code that you are about to break API compatibility.
+** Make it easy to make backwards compatible changes
+** Make it possible to make backwards incompatible changes
+** Minimise code duplication to minimise maintenance overhead
+
+* How will we test this both for unittests and in integration. And
+  what limits does that impose.
+
+Versioning
+--------------
+
+For the purposes of this discussion, "the API" is all core and
+optional extensions in the Nova tree.
+
+Versioning of the API should be a single monotonic counter. It will be
+of the form X.Y.Z where it follows the Semantic Versioning 2.0.0
+specification (http://semver.org). Eg. you increment
+
+* X when you make incompatible API changes
+* Y when you make backwards compatible changes
+* Z when you make backwards compatible bug fixes
+
+A backwards compatible change is defined as one which would be allowed
+under the OpenstAck API Change Guidelines
+
+http://wiki.openstack.org/wiki/APIChangeGuidelines
+
+A version response would look as follows
+
+::
+
+    GET /
+    {
+         "versions": [
+            {
+                "id": "v2.0",
+                "links": [
+                      {
+                        "href": "http://localhost:8774/v2/",
+                        "rel": "self"
+                    }
+                ],
+                "status": "CURRENT",
+                "version": "5.2.0"
+                "min_version": "2.0"
+            },
+       ]
+    }
+
+This specifies the min and max version that the server can
+understand. min_version will start at 2.1 representing the v2.1 API
+(which is equivalent to the V2.0 API except for XML support). It may
+eventually be increased if there are support burdens we don't feel are
+adequate to support.
+
+Client Interaction
+-----------------------
+
+A client specifies the version of the API they want via the following
+approach, a new header::
+
+  X-OS-Compute-Version: 2.114, experimental, vendor:rax
+
+This conceptually acts like the accept header.  We introduce 3
+concepts here, global API version, experimental flag, and vendor
+flags.
+
+Semantically this means:
+
+* If X-OS-Compute-Version is not provided, act as if min_version was
+  sent.
+
+* If X-OS-Compute-Version is sent, respond with the API at that
+  version. If that's outside of the range of versions supported,
+  return 406 Not Acceptable.
+
+* If X-OS-Compute-Version: latest (special keyword) return max_version
+  of the API.
+
+* If experimental is sent, return results with *all* experimental
+  extensions enabled.
+
+* If vendor:VENDORNAMESPACE is sent, return results that include out
+  of tree vendor extensions.
+
+This means out of the box, with an old client, an OpenStack
+installation will return vanilla OpenStack responses at v2. The user
+or SDK will have to ask for something different in order to get new
+features.
+
+Experimental and vendor, by being virtue of out of tree, do not
+benefit from versioning. It's an all or nothing affair. There are less
+unique snowflakes in the world than people think, and we actually want
+these things back in tree.
+
+Here is where you cover the change you propose to make in detail. How do you
+propose to solve this problem?
+
+If this is one part of a larger effort make it clear where this piece ends. In
+other words, what's the scope of this effort?
+
+Implementation design details
+-----------------------------
+
+On each request the X-OS-Computer-Version header string will be
+converted to an APIVersionRequest object in the wsgi code. Routing
+will occur in the usual manner with the version object attached to the
+request object (which all API methods expect). The API methods can
+then use this to determine their behaviour to the incoming request.
+
+What other ways could we do this thing? Why aren't we using those? This doesn't
+have to be a full literature review, but it should demonstrate that thought has
+been put into why the proposed solution is an appropriate one.
+
+Types of changes we will need to support::
+
+* Status code changes (success and error codes)
+* Allowable body parameters (affects input validation schemas too)
+* Allowable url parameters
+* General semantic changes
+* Data returned in response
+* ???
+
+THIS SECTION IS NOT COMPLETE
+
+
+Alternatives
+------------
+
+
+
+Data model impact
+-----------------
+
+None
+
+REST API impact
+---------------
+
+As described above there would be additional version information added
+to the GET /. These should be backwards compatible changes and I
+rather doubt anyone is actually using this information in practice
+anyway.
+
+Otherwise there are no changes unless a client header as described is
+supplied as part of the request.
+
+
+Security impact
+---------------
+
+None
+
+Notifications impact
+--------------------
+
+None
+
+Other end user impact
+---------------------
+
+SDK authors will need to start using the X-OS-Compute-Version header
+to get access to new features. The fact that new features will only be
+added in new versions will encourage them to do so.
+
+python-novaclient is in an identical situation and will need to be
+updated to support the new header in order to support new API
+features.
+
+Performance Impact
+------------------
+
+None
+
+Other deployer impact
+---------------------
+
+None
+
+Developer impact
+----------------
+
+This will obviously affect how Nova developers modify
+the REST API code and add new extensions.
+
+FAQ
+---
+
+* Does adding a new plugin change the version number?
+  Yes. Although a client could detect this also through /extensions
+  I think we should still bump the minor number so they know if
+  it could be present.
+
+* Do we bump a version number when error status codes change?
+
+
+
+Implementation
+==============
+
+Assignee(s)
+-----------
+
+
+Primary assignee:
+  cyeoh-0
+
+Other contributors:
+  <launchpad-id or None>
+
+Work Items
+----------
+
+Work items or tasks -- break the feature up into the things that need to be
+done to implement it. Those parts might end up being done by different people,
+but we're mostly trying to understand the timeline for implementation.
+
+
+Dependencies
+============
+
+* Include specific references to specs and/or blueprints in nova, or in other
+  projects, that this one either depends on or is related to.
+
+* If this requires functionality of another project that is not currently used
+  by Nova (such as the glance v2 API when we previously only required v1),
+  document that fact.
+
+* Does this feature require any new library dependencies or code otherwise not
+  included in OpenStack? Or does it depend on a specific version of library?
+
+
+Testing
+=======
+
+Please discuss how the change will be tested. We especially want to know what
+tempest tests will be added. It is assumed that unit test coverage will be
+added so that doesn't need to be mentioned explicitly, but discussion of why
+you think unit tests are sufficient and we don't need to add more tempest
+tests would need to be included.
+
+Is this untestable in gate given current limitations (specific hardware /
+software configurations available)? If so, are there mitigation plans (3rd
+party testing, gate enhancements, etc).
+
+
+Documentation Impact
+====================
+
+What is the impact on the docs team of this change? Some changes might require
+donating resources to the docs team to have the documentation updated. Don't
+repeat details discussed above, but please reference them here.
+
+
+References
+==========
+
+Please add any useful references here. You are not required to have any
+reference. Moreover, this specification should still make sense when your
+references are unavailable. Examples of what you could include are:
+
+* Links to mailing list or IRC discussions
+
+* Links to notes from a summit session
+
+* Links to relevant research, if appropriate
+
+* Related specifications as appropriate (e.g.  if it's an EC2 thing, link the
+  EC2 docs)
+
+* Anything else you feel it is worthwhile to refer to
-- 
1.9.1

