From 4728370c030337c327a290d61bdd42eacfa0aec1 Mon Sep 17 00:00:00 2001
From: Christopher Yeoh <cyeoh@au1.ibm.com>
Date: Thu, 9 Oct 2014 14:05:10 +1030
Subject: [PATCH] REST API Microversions

Proposal to support microversions for the Nova REST API

APIImpact

Change-Id: I49c3d590d087f9cd3c2d1898455aa296721a4f6e
---
 specs/kilo/approved/api-microversions.rst | 423 ++++++++++++++++++++++++++++++
 1 file changed, 423 insertions(+)
 create mode 100644 specs/kilo/approved/api-microversions.rst

diff --git a/specs/kilo/approved/api-microversions.rst b/specs/kilo/approved/api-microversions.rst
new file mode 100644
index 0000000..4f0b0ff
--- /dev/null
+++ b/specs/kilo/approved/api-microversions.rst
@@ -0,0 +1,423 @@
+..
+ This work is licensed under a Creative Commons Attribution 3.0 Unported
+ License.
+
+ http://creativecommons.org/licenses/by/3.0/legalcode
+
+==========================================
+REST API Microversion Support
+==========================================
+
+https://blueprints.launchpad.net/nova/+spec/api-microversions
+
+We need a way to be able to introduce changes to the REST API to both
+fix bugs and add new features. Some of these changes are backwards
+incompatible and we currently have no way of doing this.
+
+Problem description
+===================
+
+As a community we are really good at evolving interfaces and code over
+time via incremental development. We've been less good at giant big
+bang drops of code. The Nova API has become sufficiently large, and
+constantly growing through new extensions, that it's not likely to be
+able to ever do a new major version of the API because of the impact
+on users and overhead for developers of supporting multiple
+implementations.
+
+At the same time the current situation where we allow innovation in
+the API through adding extensions, has grown to the point where we now
+have extensions to extensions, under the assumption that the extension
+list is a poor man's versioning mechanism. This has led to large
+amounts of technical debt. It prevents us from making certain changes,
+like deprecating pieces of the API that are currently non sensible or
+broken. Or fixing other areas where incremental development has led to
+inconsistencies in the API which is confusing for new users.
+
+We must come up with a better way that serves the following needs:
+
+- Makes it possible to evolve the API in an incremental manner, which
+  is our strength as a community.
+- Provides backwards compatibility for users of the REST API.
+- Provides cleanliness in the code to make it less likely that we'll
+  do the wrong thing when extending or modifying the API.
+
+A great interface is one that goes out of it's way to makes it hard to
+use incorrectly. A good interface tries to be a great interface, but
+bends to the realities of the moment.
+
+Use Cases
+----------
+
+* Allows developers to modify the Nova API in backwards compatible
+  way and signal to users of the API dynamically that the change is
+  available without having to create a new API extension.
+
+* Allows developers to modify the Nova API in a non backwards
+  compatible way whilst still supporting the old behaviour. Users of
+  the REST API are able to decide if they want the Nova API to behave
+  in the new or old manner on a per request basis. Deployers
+  are able to make new backwards incompatible features available
+  without removing support for prior behaviour.
+
+* Users of the REST API are able to, on a per request basis, decide
+  which version of the API they want to use (assuming the deployer
+  supports the version they want).
+
+Project Priority
+-----------------
+
+The kilo priorities list is currently not defined. However under the
+currently proposed list of priorities it would fall under "User
+Experience" as it significantly increases the ability for us to
+improve the Nova API.
+
+Proposed change
+===============
+
+Design Priorities:
+
+* How will the end users use this, and how to we make it hard to use
+  incorrectly
+
+* How will the code be internally structured. How do we make it:
+
+** Easy to see in the code that you are about to break API compatibility.
+** Make it easy to make backwards compatible changes
+** Make it possible to make backwards incompatible changes
+** Minimise code duplication to minimise maintenance overhead
+
+* How will we test this both for unittests and in integration. And
+  what limits does that impose.
+
+Versioning
+----------
+
+For the purposes of this discussion, "the API" is all core and
+optional extensions in the Nova tree.
+
+Versioning of the API should be a single monotonic counter. It will be
+of the form X.Y where it follows the Semantic Versioning 2.0.0
+specification (http://semver.org). Eg. you increment
+
+* X when you make incompatible API changes
+* Y when you make backwards compatible changes
+
+A backwards compatible change is defined as one which would be allowed
+under the OpenStack API Change Guidelines
+
+http://wiki.openstack.org/wiki/APIChangeGuidelines
+
+A version response would look as follows
+
+::
+
+    GET /
+    {
+         "versions": [
+            {
+                "id": "v2.1",
+                "links": [
+                      {
+                        "href": "http://localhost:8774/v2/",
+                        "rel": "self"
+                    }
+                ],
+                "status": "CURRENT",
+                "version": "5.2"
+                "min_version": "2.1"
+            },
+       ]
+    }
+
+This specifies the min and max version that the server can
+understand. min_version will start at 2.1 representing the v2.1 API
+(which is equivalent to the V2.0 API except for XML support). It may
+eventually be increased if there are support burdens we don't feel are
+adequate to support.
+
+Client Interaction
+-----------------------
+
+A client specifies the version of the API they want via the following
+approach, a new header::
+
+  X-OpenStack-Compute-API-Version: 2.114, experimental, vendor:rax
+
+This conceptually acts like the accept header.  We introduce 3
+concepts here, global API version, experimental flag, and vendor
+flags.
+
+Semantically this means:
+
+* If X-OpenStack-Compute-API-Version is not provided, act as if min_version was
+  sent.
+
+* If X-OpenStack-Compute-API-Version is sent, respond with the API at that
+  version. If that's outside of the range of versions supported,
+  return 406 Not Acceptable.
+
+* If X-OpenStack-Compute-API-Version: latest (special keyword) return
+  max_version of the API.
+
+* If experimental is sent, return results with *all* experimental
+  extensions enabled.
+
+* If vendor:VENDORNAMESPACE is sent, return results that include out
+  of tree vendor extensions.
+
+This means out of the box, with an old client, an OpenStack
+installation will return vanilla OpenStack responses at v2. The user
+or SDK will have to ask for something different in order to get new
+features.
+
+Experimental and vendor, by virtue of being out of tree, do not
+benefit from versioning. It's an all or nothing affair. There are less
+unique snowflakes in the world than people think, and we actually want
+these things back in tree.
+
+Implementation design details
+-----------------------------
+
+On each request the X-OpenStack-Compute-API-Version header string will be
+converted to an APIVersionRequest object in the wsgi code. Routing
+will occur in the usual manner with the version object attached to the
+request object (which all API methods expect). The API methods can
+then use this to determine their behaviour to the incoming request.
+
+Types of changes we will need to support::
+
+* Status code changes (success and error codes)
+* Allowable body parameters (affects input validation schemas too)
+* Allowable url parameters
+* General semantic changes
+* Data returned in response
+* Removal of resources in the API
+* Removal of fields in a response object or changing the layout of the response
+
+Note: This list is not meant to be an exhaustive list
+
+Within a controller case, methods can be marked with a decorator
+to indicate what API versions they implement. For example::
+
+::
+
+>  @api_version(min_version='2.1', max_version='2.9')
+>  def show(self, req, id):
+>     pass
+>
+>  @api_version(min_version='3.0')
+>  def show(self, req, id):
+>     pass
+
+An incoming request for version 2.2.0 of the API would end up
+executing the first method, whilst an incoming request for version
+3.1.0 of the API would result in the second being executed.
+
+For cases where the method implementations are very similar with just
+minor differences a lot of duplicated code can be avoided by versioning
+internal methods intead. For example::
+
+
+>   @api_version(min_version='2.1')
+>   def _version_specific_func(self, req, arg1):
+>      pass
+>
+>   @api_version(min_version='2.5')
+>   def _version_specific_func(self, req, arg1):
+>      pass
+>
+>   def show(self, req, id):
+>      .... common stuff ....
+>      self._version_specific_func(req, "foo")
+>       .... common stuff ....
+
+
+Reducing the duplicated code to a minimum minimises maintenance
+overhead. So the technique we use would depend on individual
+circumstances of what code is common/different and where in the method
+it is.
+
+A version object is passed down to the method attached to the request
+object so it is also possible to do very specific checks in a
+method. For example::
+
+> def show(self, req, id):
+>    .... stuff ....
+>
+>    if req.ver_obj.matches(start_version, end_version):
+>      .... Do version specific stuff ....
+>
+>    ....  stuff ....
+
+
+To mark a method implementation as only available when experimental or
+vendor specific it can be marked with:
+
+@api_exp()
+@api_vendor("vendor_string")
+
+Note that you cannot combine these with the api_version decorator or
+with each other.
+
+Some prototype code which explains how this work is available here:
+
+https://github.com/cyeoh/microversions_poc
+
+The validation schema decorator would also need to be extended to support
+versioning
+
+@validation.schema(schema_definition, min_version, max_version)
+
+
+Alternatives
+------------
+
+One alternative is to make all the backwards incompatible changes at
+once and do a major API release. For example, change the url prefix to
+/v3 instead of /v2. And then support both implementations for a long
+period of time. This approach has been rejected in the past because of
+concerns around maintance overhead.
+
+Data model impact
+-----------------
+
+None
+
+REST API impact
+---------------
+
+As described above there would be additional version information added
+to the GET /. These should be backwards compatible changes and I
+rather doubt anyone is actually using this information in practice
+anyway.
+
+Otherwise there are no changes unless a client header as described is
+supplied as part of the request.
+
+
+Security impact
+---------------
+
+None
+
+Notifications impact
+--------------------
+
+None
+
+Other end user impact
+---------------------
+
+SDK authors will need to start using the X-OpenStack-Compute-API-Version header
+to get access to new features. The fact that new features will only be
+added in new versions will encourage them to do so.
+
+python-novaclient is in an identical situation and will need to be
+updated to support the new header in order to support new API
+features.
+
+Performance Impact
+------------------
+
+None
+
+Other deployer impact
+---------------------
+
+None
+
+Developer impact
+----------------
+
+This will obviously affect how Nova developers modify
+the REST API code and add new extensions.
+
+FAQ
+---
+
+* Does adding a new plugin change the version number?
+  Yes. Although a client could detect this also through /extensions
+  I think we should still bump the minor number so they know if
+  it could be present.
+
+* Do we bump a version number when error status codes change?
+
+  No. At least while we consider error status code changes a backwards
+  compatible minor one which clients aren't really interested or
+  dependent on (who actually checks error code?). Strictly speaking it
+  is a backwards incompatible change but until the API Change
+  guidelines change we will stick to this fiction. And debate this
+  elsewhere :-)
+
+
+
+Implementation
+==============
+
+Assignee(s)
+-----------
+
+
+Primary assignee:
+  cyeoh-0
+
+Other contributors:
+  <launchpad-id or None>
+
+Work Items
+----------
+
+* Implement APIVersions class
+* Implement handling of X-OpenStack-Compute-API-Version header
+* Implement routing of methods called based on version header.
+* Find and implement first API change requiring a microversion bump.
+
+
+Dependencies
+============
+
+* This is dependent on v2.1 v2-on-v3-api spec being completed.
+
+* Any nova spec which wants to make backwards compatible changes
+  to the API (such as the tasks api specification) is dependent on
+  on this change. As is any spec that wants to make any API change
+  to the v2.1 API without having to add a dummy extension.
+
+* JSON-Home is related to this though they provide different
+  services. Microversions allows clients to control which version of
+  the API they are exposed to and JSON-Home describes that API
+  allowing for resource discovery.
+
+Testing
+=======
+
+It is not feasible for tempest to test all possible combinations
+of the API supported by microversions. We will have to pick specific
+versions which are representative of what is implemented. The existing
+Nova tempest tests will be used as the baseline for future API
+version testing.
+
+Documentation Impact
+====================
+
+The long term aim is to produce API documentation at least partially
+automated using the current json schema support and future JSON-Home
+support. This problem is fairly orthogonal to this specification
+though.
+
+References
+==========
+
+* Semver http://semver.org
+
+* Links to mailing list or IRC discussions
+
+* Links to notes from a summit session
+
+* Links to relevant research, if appropriate
+
+* Related specifications as appropriate (e.g.  if it's an EC2 thing, link the
+  EC2 docs)
+
+* Anything else you feel it is worthwhile to refer to
-- 
1.9.1

